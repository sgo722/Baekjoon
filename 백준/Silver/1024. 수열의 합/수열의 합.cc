#include <bits/stdc++.h>
using namespace std;

int N,L;
pair<int,int> ans = {-1,-1};
int main(){
    cin >> N >> L;
    for(int i=L; i<=100; i++){
        int mid = N / i;
        for(int j=0; j<i; j++){
            int sum = 0;
            int start=mid-j;
            if(start < 0) break;
            for(int k=start; k<start+i; k++){
                sum += k;
            }
            if(sum == N){
                ans = {start,i};
                break;
            }
        }
        if(ans.first != -1) break;
    }
    if(ans.first == -1){
        cout << -1 << "\n";
    }else{
        for(int i=ans.first; i<ans.first+ans.second; i++){
            cout << i << " ";
        }
    }

    return 0;
}


/**
 * 22:10 시작
 * 시간제한 2초
 * N과 L이 주어지는데
 * 연속된 구간의 합이 N이고 구간내부 각각의 길이가 L보다는 큰 구간 중 가장 짧은 구간을 구해야함.
 * 가장 짧은 구간에 속하는 값들 출력
 * 없으면 -1을 출력
 *
 * 입력값 제한)
 * 1. N은 10억보다 작다.
 * 2. 2 < L < 100
 *
 * 1. 각 구간의 합에 대해서 알아야하지 않을까
 * 2. 그 구간의 최솟값이 L이상이면 된다.
 *
 * 시간제한은 2초이기 때문에 2억번 연산에 해결을 해야한다.
 * 주어진 N의 값을 임의의구간에 포함된 숫자의 개수로 나눈다.
 * 나눠진 몫을 위주로 구간을 만들어보고 성립하는 구간이 있으면 출력한다.
 * 구간의 최대값이 L보다 작아지면 -1이 정답이 된다.
 * 아이디어 도출 22:31
 * 구현 시작 22:31
 * 문제 파악 오류 확인 22:37
 * 구간의 길이가 L이라는 것을 이제 깨달음.
 * 그러면 N이라는 값을 L이라는 값을 나누고 그 주변의 값들을 나눠진 값을 중심으로
 * 나눠진 값이 최대혹은 최대가 되는 상황을 만들어보고 통과가 되는 배열이 있다면 출력
 * L이 최대가 되는 상황에서 전체합은 최소인데 이 값이 N보다 크다면 -1을 출력한다.
 * 아이디어 재도출 22:39
 * 구현 시작 22:39
 * 구현 완료 23:13
*/